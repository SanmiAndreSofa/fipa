
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Fingerprint Analysis</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-01-20"><meta name="DC.source" content="fingerprint.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Fingerprint Analysis</h1><!--introduction--><p><b>Biometric Methods and Computer Vision in MATLAB&reg;</b></p><pre>Roland Bruggmann, BSc student Information Technology
Specialisation in Computer Perception and Virtual Reality CPVR
&lt;mailto:roland.bruggmann@students.bfh.ch&gt;</pre><pre>Bern University of Applied Sciences, Engineering and Information Technology
Biel/Bienne, January 2016</pre><pre>References:</pre><pre>Maltoni, D. et al.: Handbook of Fingerprint Recognition, 2. ed., chapter
3: Fingerprint Analysis and Representation. Springer 2009.</pre><pre>Bazen, Asker M. and Gerez, Sabih H.: Systematic Methods for the
Computation of the Directional Fields and Singular Points of Fingerprints.
IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 24,
No. 7, July 2002 (p. 905-919).</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">1) Capture</a></li><li><a href="#3">2) Preprocessing</a></li><li><a href="#4">2.1) Quality Enhancement</a></li><li><a href="#5">2.2) Variance, Quality and Segmentation</a></li><li><a href="#6">2.3) Gradients, directions and coherence</a></li><li><a href="#7">2.4) Binarisation and skeleton</a></li><li><a href="#8">3.) Feature Extraction</a></li><li><a href="#9">3.1) Global Features</a></li><li><a href="#10">3.2) Minutiae</a></li><li><a href="#11">3.2.1) Ridge endings</a></li><li><a href="#12">3.2.2) Bifurcations</a></li></ul></div><p>Clear matrices, close figures and clear cmd wnd.</p><pre class="codeinput">clear <span class="string">variables</span>; clear <span class="string">globals</span>; close <span class="string">all</span>; clc;
</pre><h2>1) Capture<a name="2"></a></h2><pre>Our capture is reduced to a read in of a raw fingerprint image.
We use fingerprint images from FVC 2004, database 3, set B (see
International Competition for Fingerprint Verification Algorithms 2004,
BioLab, University of Bologna, Online: &lt;http://bias.csr.unibo.it/fvc2004/&gt;).
We assume the image is in grayscales (white: 255, black: 0).</pre><pre class="codeinput"><span class="comment">% I = imread('../FVC2004/DB3_B/103_6.tif');</span>
I = imread(<span class="string">'../fp-images/11_4.png'</span>);
[sizeX, sizeY] = size(I);
figure; imshow(I); axis <span class="string">off</span>; title(<span class="string">'Original Image'</span>);
</pre><img vspace="5" hspace="5" src="fingerprint_01.png" alt=""> <h2>2) Preprocessing<a name="3"></a></h2><h2>2.1) Quality Enhancement<a name="4"></a></h2><p>To largen the image quality we apply a high-pass filter (Laplacian of Gaussian LoG). First, we transform the image to its frequency domain using a Fast Fourier Transformation (FFT), then we augment the amplitude of the dominant frequencies over relatively small regions and finally retransform the image back to the spatial domain by the use of an inverse FFT (IFFT).</p><pre class="codeinput"><span class="comment">% Convert the image from spatial to frequency domain and shift low</span>
<span class="comment">% frequencies to the center of the spectrum.</span>
J = fftshift(fft2(double(I)));
<span class="comment">% Delete low frequencies using a high-pass filter</span>
hsize = 3;
hsigma = 0.2;
h = fspecial(<span class="string">'log'</span>, hsize, hsigma);
Jh = conv2(J,h);
border = (hsize-1)/2;
rJh = Jh(1+border:end-border,1+border:end-border);
subJh = minus(J, rJh);
<span class="comment">% Shift high frequencies back to the center of the spectrum and convert</span>
<span class="comment">% the image from frequency to spatial domain and extract real part.</span>
Ih = ifft2(fftshift(subJh));
Iq = abs(Ih);

figure; imshow(log(max(abs(J),    1e-6)),[]), colormap(jet(64)); axis <span class="string">off</span>; title(<span class="string">'Amplitudes'</span>); hold <span class="string">off</span>;
figure; imshow(log(max(abs(Jh), 1e-6)),[]), colormap(jet(64)); axis <span class="string">off</span>; title(<span class="string">'After LoG'</span>);  hold <span class="string">off</span>;
figure; imshow(Iq, []); axis <span class="string">off</span>; title(<span class="string">'Reslut'</span>); hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="fingerprint_02.png" alt=""> <img vspace="5" hspace="5" src="fingerprint_03.png" alt=""> <img vspace="5" hspace="5" src="fingerprint_04.png" alt=""> <h2>2.2) Variance, Quality and Segmentation<a name="5"></a></h2><p>Segmentation using Gabor filters, cp. Maltoni, chapter 3.4 Segmentation (p. 116-119).</p><pre class="codeinput">[V, outer, Iseg] = segmentTexture(I);
<span class="comment">% Q = TODO</span>

figure; imshow(V, []);    axis <span class="string">off</span>; title(<span class="string">'Variance'</span>);  hold <span class="string">off</span>;
<span class="comment">% figure; imshow(Q, []);    axis off; title('Quality');  hold off;</span>
figure; imshow(Iseg, []); axis <span class="string">off</span>; title(<span class="string">'Segmented'</span>); hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="fingerprint_05.png" alt=""> <img vspace="5" hspace="5" src="fingerprint_06.png" alt=""> <h2>2.3) Gradients, directions and coherence<a name="6"></a></h2><p>cp. Maltoni, chapter 3.2 Local Ridge Orientation, especially 3.2.1 Gradient-based approaches, p. 102-106 and Bazen/Gerez.</p><pre class="codeinput"><span class="comment">% Gradients Gx and Gy</span>
f = fspecial(<span class="string">'gaussian'</span>, 7, 1); <span class="comment">% hsize: 7; sigma: 1</span>
[fx,fy] = gradient(f);
Gx = filter2(fx, Iseg);
Gy = filter2(fy, Iseg);

<span class="comment">% Local ridge orientation D (in radiant)</span>
f = fspecial(<span class="string">'gaussian'</span>, 17, 3); <span class="comment">% hsize: 17; sigma: 3</span>
Gxy = Gx.*Gy; Gxy = 2*filter2(f, Gxy);
Gxx = Gx.^2;  Gxx = filter2(f, Gxx);
Gyy = Gy.^2;  Gyy = filter2(f, Gyy);
denom = sqrt((Gxx - Gyy).^2 + Gxy.^2) + eps;
sin2theta = Gxy./denom;         sin2theta = filter2(f, sin2theta);
cos2theta = (Gxx-Gyy)./denom;   cos2theta = filter2(f, cos2theta);
D = pi/2 + atan2(sin2theta,cos2theta)/2;

<span class="comment">% Covariance C as reliability of orientation</span>
Imin = (Gyy+Gxx)/2 - (Gxx-Gyy).*cos2theta/2 - Gxy.*sin2theta/2;
Imax = Gyy+Gxx - Imin;
C = 1 - Imin./(Imax+.001);
C = C.*(denom&gt;.001);

figure; imshow(I, []); alpha <span class="string">.5</span>; axis <span class="string">off</span>; title(<span class="string">'Gradients'</span>);  hold <span class="string">on</span>; quiver(Gx,Gy); hold <span class="string">off</span>;
figure; directionmap(D, 7, I); title(<span class="string">'Directions'</span>); hold <span class="string">off</span>;
figure; imshow(C, []); axis <span class="string">off</span>; title(<span class="string">'Coherence'</span>);  hold <span class="string">off</span>;
</pre>

<img vspace="5" hspace="5" src="fingerprint_07.png" alt=""> 
<img vspace="5" hspace="5" src="fingerprint_07_zoom.png" alt=""> 
<img vspace="5" hspace="5" src="fingerprint_08.png" alt=""> 
<img vspace="5" hspace="5" src="fingerprint_08_zoom.png" alt=""> 
<img vspace="5" hspace="5" src="fingerprint_09.png" alt=""> 

<h2>2.4) Binarisation and skeleton<a name="7"></a></h2><p>(Thresholded binarisation should be replace by local binarisation.)</p><pre class="codeinput">binarised = Iseg(:,:,1)&gt;230;

<span class="comment">% We generate a skeleton by thinning the region. We remove pixels from the</span>
<span class="comment">% border and spur pixels 20 times.</span>
thinned       = ~bwmorph(~binarised,<span class="string">'thin'</span>,Inf); <span class="comment">% 'skel'</span>
skeletonised  =  bwmorph(thinned,<span class="string">'spur'</span>,20);

figure; imshow(binarised);    axis <span class="string">off</span>; title(<span class="string">'Binarised'</span>);     hold <span class="string">off</span>;
figure; imshow(skeletonised); axis <span class="string">off</span>; title(<span class="string">'Skeleton'</span>);      hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="fingerprint_10.png" alt=""> <img vspace="5" hspace="5" src="fingerprint_11.png" alt=""> <h2>3.) Feature Extraction<a name="8"></a></h2><h2>3.1) Global Features<a name="9"></a></h2><p>To extraxt the global features we use the coherence map. This time, we choose a large sigma for the Gaussian weighting used to sum the gradient moments (cp. Maltoni, p. 124).</p><pre class="codeinput">[Gx2, Gy2, D2, C2] = ridgeorient(I, 1, 17, 3);
Imin = imregionalmin(C2);
<span class="comment">% Global = TODO</span>

figure; imshow(C2, []);   axis <span class="string">off</span>; title(<span class="string">'Coherence 2'</span>);  hold <span class="string">off</span>;
figure; imshow(Imin, []); axis <span class="string">off</span>; title(<span class="string">'Minima'</span>);       hold <span class="string">off</span>;
<span class="comment">%figure; imshow(Global, []); axis off; title('Global Features'); hold off; TODO</span>
</pre><img vspace="5" hspace="5" src="fingerprint_12.png" alt=""> <img vspace="5" hspace="5" src="fingerprint_13.png" alt=""> <h2>3.2) Minutiae<a name="10"></a></h2><p>cp. Maltoni, chapter 3.7 Minutiae Detection (p. 143-157). Reference: Athi Narayanan S <a href="http://sites.google.com/site/athisnarayanan/s_athi1983@yahoo.co.in">http://sites.google.com/site/athisnarayanan/s_athi1983@yahoo.co.in</a></p><pre class="codeinput">Im = skeletonised;

<span class="comment">% Structure element</span>
SE2 = 3;
mat = zeros(SE2);
w = floor(SE2/2);
center = w + 1;

<span class="comment">% Temporary data to work with</span>
row = sizeX + 2*w; <span class="comment">% enhance area at left and right (Randproblem)</span>
col = sizeY + 2*w; <span class="comment">% enhance area at top and bottom (Randproblem)</span>

double <span class="string">temp(row,col)</span>;
temp = zeros(row,col);
temp( (center):(end-w), (center):(end-w) ) = Im(:,:);

<span class="comment">% Minutiae containers</span>
ridge       = zeros(row,col);
bifurcation = zeros(row,col);

<span class="keyword">for</span> x = (center+10):(sizeX+w-10)
    <span class="keyword">for</span> y = (center+10):(sizeY+w-10)
        <span class="comment">% fill in mat with values from temp</span>
        e = 1;
        <span class="keyword">for</span> k = x-w:x+w
            f = 1;
            <span class="keyword">for</span> l = y-w:y+w
                mat(e,f) = temp(k,l);
                f = f+1;
            <span class="keyword">end</span>
            e=e+1;
        <span class="keyword">end</span>;
        <span class="keyword">if</span>( mat(center,center) == 0 )
            ridge(x,y)       = sum(sum(~mat));
            bifurcation(x,y) = sum(sum(~mat));
        <span class="keyword">end</span>;
    <span class="keyword">end</span>;
<span class="keyword">end</span>;
</pre><h2>3.2.1) Ridge endings<a name="11"></a></h2><p>find 2 in 3x3</p><pre class="codeinput">[ridgeX, ridgeY] = find(ridge == 2);
ridgeLen = length(ridgeX);

<span class="comment">% Display</span>
re = zeros(row,col,3);
re(:,:,1) = temp .* 255;
re(:,:,2) = temp .* 255;
re(:,:,3) = temp .* 255;
<span class="keyword">for</span> i=1:ridgeLen
    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)-3),2:3)=0;
    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)+3),2:3)=0;
    re((ridgeX(i)-3),(ridgeY(i)-3):(ridgeY(i)+3),2:3)=0;
    re((ridgeX(i)+3),(ridgeY(i)-3):(ridgeY(i)+3),2:3)=0;

    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)-3),1)=255;
    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)+3),1)=255;
    re((ridgeX(i)-3),(ridgeY(i)-3):(ridgeY(i)+3),1)=255;
    re((ridgeX(i)+3),(ridgeY(i)-3):(ridgeY(i)+3),1)=255;
<span class="keyword">end</span>
</pre><h2>3.2.2) Bifurcations<a name="12"></a></h2><p>find 4 in 3x3</p><pre class="codeinput">[bifurcationX, bifurcationY] = find(bifurcation == 4);
bifurcationLen = length(bifurcationX);

<span class="comment">% Display</span>
bif=zeros(row,col,3);
bif(:,:,1) = temp .* 255;
bif(:,:,2) = temp .* 255;
bif(:,:,3) = temp .* 255;
<span class="keyword">for</span> i=1:bifurcationLen
    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)-3),1:2)=0;
    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)+3),1:2)=0;
    bif((bifurcationX(i)-3),(bifurcationY(i)-3):(bifurcationY(i)+3),1:2)=0;
    bif((bifurcationX(i)+3),(bifurcationY(i)-3):(bifurcationY(i)+3),1:2)=0;

    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)-3),3)=255;
    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)+3),3)=255;
    bif((bifurcationX(i)-3),(bifurcationY(i)-3):(bifurcationY(i)+3),3)=255;
    bif((bifurcationX(i)+3),(bifurcationY(i)-3):(bifurcationY(i)+3),3)=255;
<span class="keyword">end</span>

figure; imshow(re, []);  axis <span class="string">off</span>; title(<span class="string">'Ridge endings'</span>); hold <span class="string">off</span>;
figure; imshow(bif, []); axis <span class="string">off</span>; title(<span class="string">'Bifurcations'</span>);  hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="fingerprint_14.png" alt=""> <img vspace="5" hspace="5" src="fingerprint_15.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Fingerprint Analysis
% *Biometric Methods and Computer Vision in MATLAB(R)*
%
%  Roland Bruggmann, BSc student Information Technology
%  Specialisation in Computer Perception and Virtual Reality CPVR
%  <mailto:roland.bruggmann@students.bfh.ch>
% 
%  Bern University of Applied Sciences, Engineering and Information Technology
%  Biel/Bienne, January 2016
% 
%  
%  References:
%  
%  Maltoni, D. et al.: Handbook of Fingerprint Recognition, 2. ed., chapter
%  3: Fingerprint Analysis and Representation. Springer 2009.
%  
%  Bazen, Asker M. and Gerez, Sabih H.: Systematic Methods for the
%  Computation of the Directional Fields and Singular Points of Fingerprints.
%  IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 24, 
%  No. 7, July 2002 (p. 905-919).
%%
% Clear matrices, close figures and clear cmd wnd.
clear variables; clear globals; close all; clc;

%% 1) Capture
%  Our capture is reduced to a read in of a raw fingerprint image.
%  We use fingerprint images from FVC 2004, database 3, set B (see
%  International Competition for Fingerprint Verification Algorithms 2004,
%  BioLab, University of Bologna, Online: <http://bias.csr.unibo.it/fvc2004/>). 
%  We assume the image is in grayscales (white: 255, black: 0).

% I = imread('../FVC2004/DB3_B/103_6.tif');
I = imread('../fp-images/11_4.png');
[sizeX, sizeY] = size(I);
figure; imshow(I); axis off; title('Original Image');

%% 2) Preprocessing
%% 2.1) Quality Enhancement
% To largen the image quality we apply a high-pass filter (Laplacian of Gaussian LoG). 
% First, we transform the image to its frequency domain using a Fast Fourier
% Transformation (FFT), then we augment the amplitude of the dominant frequencies
% over relatively small regions and finally retransform the image back to the 
% spatial domain by the use of an inverse FFT (IFFT).

% Convert the image from spatial to frequency domain and shift low
% frequencies to the center of the spectrum.
J = fftshift(fft2(double(I)));
% Delete low frequencies using a high-pass filter
hsize = 3;
hsigma = 0.2;
h = fspecial('log', hsize, hsigma);
Jh = conv2(J,h);
border = (hsize-1)/2;
rJh = Jh(1+border:end-border,1+border:end-border);
subJh = minus(J, rJh);
% Shift high frequencies back to the center of the spectrum and convert 
% the image from frequency to spatial domain and extract real part.
Ih = ifft2(fftshift(subJh));
Iq = abs(Ih);

figure; imshow(log(max(abs(J),    1e-6)),[]), colormap(jet(64)); axis off; title('Amplitudes'); hold off;
figure; imshow(log(max(abs(Jh), 1e-6)),[]), colormap(jet(64)); axis off; title('After LoG');  hold off;
figure; imshow(Iq, []); axis off; title('Reslut'); hold off;

%% 2.2) Variance, Quality and Segmentation
% Segmentation using Gabor filters,
% cp. Maltoni, chapter 3.4 Segmentation (p. 116-119).
[V, outer, Iseg] = segmentTexture(I);
% Q = TODO

figure; imshow(V, []);    axis off; title('Variance');  hold off;
% figure; imshow(Q, []);    axis off; title('Quality');  hold off;
figure; imshow(Iseg, []); axis off; title('Segmented'); hold off;

%% 2.3) Gradients, directions and coherence
% cp. Maltoni, chapter 3.2 Local Ridge Orientation, 
% especially 3.2.1 Gradient-based approaches, p. 102-106 and Bazen/Gerez.

% Gradients Gx and Gy
f = fspecial('gaussian', 7, 1); % hsize: 7; sigma: 1
[fx,fy] = gradient(f);
Gx = filter2(fx, Iseg);
Gy = filter2(fy, Iseg);

% Local ridge orientation D (in radiant)
f = fspecial('gaussian', 17, 3); % hsize: 17; sigma: 3
Gxy = Gx.*Gy; Gxy = 2*filter2(f, Gxy);
Gxx = Gx.^2;  Gxx = filter2(f, Gxx); 
Gyy = Gy.^2;  Gyy = filter2(f, Gyy);
denom = sqrt((Gxx - Gyy).^2 + Gxy.^2) + eps;
sin2theta = Gxy./denom;         sin2theta = filter2(f, sin2theta);
cos2theta = (Gxx-Gyy)./denom;   cos2theta = filter2(f, cos2theta);
D = pi/2 + atan2(sin2theta,cos2theta)/2;

% Covariance C as reliability of orientation
Imin = (Gyy+Gxx)/2 - (Gxx-Gyy).*cos2theta/2 - Gxy.*sin2theta/2;
Imax = Gyy+Gxx - Imin;
C = 1 - Imin./(Imax+.001);
C = C.*(denom>.001);

figure; imshow(I, []); alpha .5; axis off; title('Gradients');  hold on; quiver(Gx,Gy); hold off;
figure; directionmap(D, 7, I); title('Directions'); hold off;
figure; imshow(C, []); axis off; title('Coherence');  hold off;

%% 2.4) Binarisation and skeleton
% (Thresholded binarisation should be replace by local binarisation.)
binarised = Iseg(:,:,1)>230;

% We generate a skeleton by thinning the region. We remove pixels from the 
% border and spur pixels 20 times.
thinned       = ~bwmorph(~binarised,'thin',Inf); % 'skel'
skeletonised  =  bwmorph(thinned,'spur',20);

figure; imshow(binarised);    axis off; title('Binarised');     hold off;
figure; imshow(skeletonised); axis off; title('Skeleton');      hold off;

%% 3.) Feature Extraction
%% 3.1) Global Features
% To extraxt the global features we use the coherence map. This time, we 
% choose a large sigma for the Gaussian weighting used to sum the 
% gradient moments (cp. Maltoni, p. 124).
[Gx2, Gy2, D2, C2] = ridgeorient(I, 1, 17, 3);
Imin = imregionalmin(C2);
% Global = TODO

figure; imshow(C2, []);   axis off; title('Coherence 2');  hold off;
figure; imshow(Imin, []); axis off; title('Minima');       hold off;
%figure; imshow(Global, []); axis off; title('Global Features'); hold off; TODO

%% 3.2) Minutiae
% cp. Maltoni, chapter 3.7 Minutiae Detection (p. 143-157).
% Reference: Athi Narayanan S http://sites.google.com/site/athisnarayanan/s_athi1983@yahoo.co.in

Im = skeletonised;

% Structure element
SE2 = 3;
mat = zeros(SE2);
w = floor(SE2/2);
center = w + 1;

% Temporary data to work with
row = sizeX + 2*w; % enhance area at left and right (Randproblem)
col = sizeY + 2*w; % enhance area at top and bottom (Randproblem)

double temp(row,col);
temp = zeros(row,col);
temp( (center):(end-w), (center):(end-w) ) = Im(:,:);

% Minutiae containers
ridge       = zeros(row,col);
bifurcation = zeros(row,col);

for x = (center+10):(sizeX+w-10)
    for y = (center+10):(sizeY+w-10)
        % fill in mat with values from temp
        e = 1;
        for k = x-w:x+w
            f = 1;
            for l = y-w:y+w
                mat(e,f) = temp(k,l);
                f = f+1;
            end
            e=e+1;
        end;
        if( mat(center,center) == 0 )
            ridge(x,y)       = sum(sum(~mat));
            bifurcation(x,y) = sum(sum(~mat));
        end;
    end;
end;

%% 3.2.1) Ridge endings
% find 2 in 3x3
[ridgeX, ridgeY] = find(ridge == 2);
ridgeLen = length(ridgeX);

% Display
re = zeros(row,col,3);
re(:,:,1) = temp .* 255;
re(:,:,2) = temp .* 255;
re(:,:,3) = temp .* 255;
for i=1:ridgeLen
    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)-3),2:3)=0;
    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)+3),2:3)=0;
    re((ridgeX(i)-3),(ridgeY(i)-3):(ridgeY(i)+3),2:3)=0;
    re((ridgeX(i)+3),(ridgeY(i)-3):(ridgeY(i)+3),2:3)=0;
    
    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)-3),1)=255;
    re((ridgeX(i)-3):(ridgeX(i)+3),(ridgeY(i)+3),1)=255;
    re((ridgeX(i)-3),(ridgeY(i)-3):(ridgeY(i)+3),1)=255;
    re((ridgeX(i)+3),(ridgeY(i)-3):(ridgeY(i)+3),1)=255;
end

%% 3.2.2) Bifurcations
% find 4 in 3x3
[bifurcationX, bifurcationY] = find(bifurcation == 4);
bifurcationLen = length(bifurcationX);

% Display
bif=zeros(row,col,3);
bif(:,:,1) = temp .* 255;
bif(:,:,2) = temp .* 255;
bif(:,:,3) = temp .* 255;
for i=1:bifurcationLen
    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)-3),1:2)=0;
    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)+3),1:2)=0;
    bif((bifurcationX(i)-3),(bifurcationY(i)-3):(bifurcationY(i)+3),1:2)=0;
    bif((bifurcationX(i)+3),(bifurcationY(i)-3):(bifurcationY(i)+3),1:2)=0;
    
    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)-3),3)=255;
    bif((bifurcationX(i)-3):(bifurcationX(i)+3),(bifurcationY(i)+3),3)=255;
    bif((bifurcationX(i)-3),(bifurcationY(i)-3):(bifurcationY(i)+3),3)=255;
    bif((bifurcationX(i)+3),(bifurcationY(i)-3):(bifurcationY(i)+3),3)=255;
end

figure; imshow(re, []);  axis off; title('Ridge endings'); hold off;
figure; imshow(bif, []); axis off; title('Bifurcations');  hold off;

##### SOURCE END #####
--></body></html>